
# load kvm driver

kvm is built as driver, so it must be loaded.
* use /proc/kcore to debug current running kernel
* download dbg package of current kernel
```
$ sudo crash /proc/kcore usr/lib/debug/vmlinux-4.4.36-2
...
crash> mod -S ./tmp/usr/lib/debug/
     MODULE       NAME                    SIZE  OBJECT FILE
...
ffffffffa00e5900  kvm                   415201  ./tmp/usr/lib/debug/usr/lib/modules/4.4.36-2-pserver/kernel/arch/x86/kvm/kvm.ko
...
```

vm_list is a global variable of kvm driver. We can check that value.
```
crash> p vm_list
vm_list = $1 = {
  next = 0xffff8804063e89f8, 
  prev = 0xffff8804063e89f8
}
```

vm_list exists inside of "struct kvm". So we need offsetof macro to get the address of "struct kvm".
* offsetof shows the offset of vm_list is 0x9f8
* the address of struct kvm is 0xffff8804063e89f8 - 0x9f8
* use p/x to print data of structure
```
crash> macro define offsetof(t, f) &((t *) 0)->f)
crash> p offsetof(struct kvm, vm_list)
$2 = (struct list_head *) 0x9f8
crash> p/x *(struct kvm *)(0xffff8804063e89f8 - 0x9f8)
$3 = {
  mmu_lock = {
    {
      rlock = {
        raw_lock = {
          val = {
            counter = 0x0
          }
        }
      }
    }
  }, 
  slots_lock = {
...
```

Use ps to find PID of qemu
* this server changed program name of qemu into kvm. kvm process is not kvm driver.
```
crash> ps | grep kvm
    257      2   0  ffff880408c67000  IN   0.0       0      0  [kvm-irqfd-clean]
   7704   7703   5  ffff880406395400  IN   2.5 9035580 426588  kvm
   7705   7703   3  ffff8803fbc12a00  IN   2.5 9035580 426588  kvm
   7706   7703   7  ffff8803fbc13800  IN   2.5 9035580 426588  kvm
   7707   7703   1  ffff8803fbc11c00  IN   2.5 9035580 426588  kvm
   7708   7703   4  ffff8803fbc10e00  IN   2.5 9035580 426588  kvm
   7709   7703   2  ffff8803fbc17000  IN   2.5 9035580 426588  kvm
   7710      2   4  ffff88040947e200  IN   0.0       0      0  [kvm-pit/7704]
...
crash> task 7704
PID: 7704   TASK: ffff880406395400  CPU: 5   COMMAND: "kvm"
crash> task 7704
PID: 7704   TASK: ffff880406395400  CPU: 5   COMMAND: "kvm"
struct task_struct {
  state = 1, 
  stack = 0xffff8802e0768000, 
  usage = {
    counter = 2
  ...
```

mm field of "struct kvm" and "struct task_struct" must be the same.
```
crash> task 7704 | grep 'mm ='
      start_comm = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
  mm = 0xffff8800375503c0, 
  active_mm = 0xffff8800375503c0, 
  comm = "kvm\000\000)\000\000oot\000\000\000\000", 
crash> p/x ((struct kvm *)0xffff8804063e8000).mm
$6 = 0xffff8800375503c0
```

struct kvm has vcpus array that has CPU context of each virtual CPUs
* http://elixir.free-electrons.com/linux/latest/source/include/linux/kvm_host.h#L380
```
crash> p/x ((struct kvm *)0xffff8804063e8000).vcpus
$7 = {0xffff8803fbfa0000, 0xffff8800616a0000, 0xffff8802de498000, 0xffff8802de658000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
```

kvm_vcpu addresses are 0xffff8803fbfa0000, 0xffff8800616a0000, 0xffff8802de498000, 0xffff8802de658000 because there are 4 virtual CPUs.
And kvm_vcpu is included in "struct vcpu_vmx" or "struct vcpu_svm". The first element of "struct vcpu_vmx" and "struct vcpu_svm" is "struct kvm_vcpu". Therefore the address of kvm_vcpu is the address of vcpu_vmx or vcpu_svm.
* vmx is INTEL virtualization and svm is AMD

crash can show a structure data with struct command
* struct STRUCT-NAME ADDRESS
* -o: print offset of each element
* "struct STRUCT-NAME" prints structure definition
```
crash> struct vcpu_vmx 0xffff8803fbfa0000
struct vcpu_vmx {
  vcpu = {
    kvm = 0xffff8804063e8000, 
    preempt_notifier = {
      link = {
        next = 0x0, 
        pprev = 0xffff8803fbc13a00
      }, 
      ops = 0xffffffffa020f800 <kvm_preempt_ops>
    }, 
    cpu = 0, 
    vcpu_id = 0, 
    srcu_idx = 0, 
```

register values of VCPU is stored in kvm_vcpu.arch.regs
* regs has http://elixir.free-electrons.com/linux/latest/source/arch/x86/include/asm/kvm_host.h#L127
```
crash> struct -x kvm_vcpu.arch 0xffff8803fbfa0000
  arch = {
    regs = {0x0, 0xffffffff8184d360, 0x0, 0xffffffff818d6da0, 0x6df4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x12e31946, 0x58f3b4edd7a, 0xffffffff81800000, 0x0, 0xffffffff81800000, 0xffffffed, 0xffffffff8100e4a6}, 
    regs_avail = 0xffe1ffef, 
    regs_dirty = 0x10000, 
    cr0 = 0x80050033, 
```
